链接
====
链接(linking)是将各种代码和数据片段收集并合成为一个单一文件，这个文件可被 *加载(复制)* 到内存并执行。
链接可执行与 *编译时*、*加载时* 或 *运行时* 。

编译器驱动程序
--------------
大多数编译系统提供 *编译器驱动程序(compiler driver)* ，调用 *预处理器(cpp)* 、 *编译器(ccl)* 、 *汇编器(as)* 和 *链接器(ld)* 。

静态链接
---------
*静态链接器(static linker)* 以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。

链接器的任务:
 - 符号解析(symbol resolution)
 - 重定位(relocation)

目标文件
--------
目标文件有三种形式:
 - 可重定位目标文件。由编译器和汇编器生成。
 - 可执行目标文件。由链接器生成。
 - 共享目标文件。

.. tip:: 

    现在 x86-64 Linux 和 Unix 系统使用 *可执行链接格式(Executable and Linkable Format, ELF)* 。

可重定位目标文件
----------------
以 ELF 可重定位目标文件的格式为例。

=========  ===========================================================================================================
文件组成    描述
=========  ===========================================================================================================
ELF 头     生成该文件的系统的字的大小和字节顺序、ELF 头的大小、目标文件的类型、架构类型、节头部表的文件偏移，以及节头部表中条目的大小和数量
.text      以编译程序的机器代码
.rodata    只读数据
.data      已初始化的全局和静态 C 变量
.bss       未初始化的全局和静态 C 变量以及所有被初始化为 0 的全局或静态变量。仅作为占位符，因为未初始化变量无需分配内存
.symtab    符号表，存放程序中定义和引用的函数和全局变量的信息
.rel.text  链接器把该目标文件组合时，需要修改这些位置
.rel.data  被模块引用或定义的所有全局变量的重定位信息
.debug     调试符号表(局部变量和类型定义，定义和引用的全局变量以及原始源文件)，编译器加 -g 才会生成
.link      原始程序中的行号和 .text 节中机器指令之间的映射。编译器加 -g 才会生成
.strtab    字符串表（.symtab 和 .debug 节中的符号表，以及节头部中的节名字）
节头部表    
=========  ===========================================================================================================

符号和符号表
------------
在链接器的上下文中，有三种不同的符号:
 - 全局符号: 由模块 m 定义并能被其他模块引用的 *非静态的 C 函数和全局变量*
 - 外部符号: 由其他模块定义并被模块 m 引用的 *非静态 C 函数和全局变量*
 - 局部符号: 只被模块 m 定义和引用的 *带 static 属性的 c 函数和全局变量*

.. tip:: 利用 static 属性隐藏变量和函数名字

    任何带有 static 属性声明的全局变量和函数都是模块私有的。反之，都是公共的，可以被其他模块访问。

.symbol 节中包含 ELF 符号表。如下展示了每个条目的格式。

.. code-block:: c

    typedef struct
    {
        int   name;       /* 字符串表中的字节偏移 */
        char  type:4,     /* 数据或函数 */
              binding:4;  /* 本地或全局 */
        char  reserved;
        short section;    /* 到节头部表的索引 */
        long  value;      /* 对于可重定位模块，表示距定义目标的节的起始位置的偏移；对于可执行目标文件，表示绝对运行地址 */
        long  size;       /* 目标大小(byte) */
    } Elf64_Symbol;

符号解析
--------
链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。

链接器如何解析多重定义的全局符号
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
可重定位目标文件的符号表里的全局符号非 `强(strong)` 即 `弱(weak)` 。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。
根据强弱符号的定义， Linux 链接器使用下面规则来处理多重定义的符号名：

 - 不允许有多个同名的强符号
 - 如果有一个强符号和多个若符号同名，那么选择强符号
 - 如果有多个弱符号同名，那么从这些弱符号中任选一个

.. tip::

    gcc 可利用 GCC-fno-common 或 -Werror 选项，在遇到多重定义的全局符号时，触发错误。

与静态库链接
^^^^^^^^^^^^^^
链接器在构造可执行文件时，只 `复制` 静态库里的被应用程序引用的目标模块。

重定位
-------
重定位由两部组成：
 - 重定位节和符号定义
 - 重定位节中的符号引用

重定位条目
^^^^^^^^^^^
ELF 重定位条目的格式如下：

.. code:: C

    typedef struct
    {
        long offset;     /* 需要被修改的引用的节偏移 */
        long typ3:32,    /* 告知链接器如何修改新的引用 */
             symbol:32;  /* 标识被修改应用应该指向的符号 */
        long addend;     /* 
    } Elf64_Rela;

ELF 定义了32种不同的重定位类型, 我们只关心两种最基本的重定位类型:
 - R_X86_64_PC32: 重定位一个使用32位 PC 相对地址的引用
 - R_X86_64_32: 重定位一个使用32位绝对地址的引用

重定位符号引用
^^^^^^^^^^^^^^^^
TODO:

可执行目标文件
--------------

加载可执行目标文件
-------------------

动态链接共享库
--------------
`共享库` 是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，
